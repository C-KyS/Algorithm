// 空间中分布着n个龙鳞火炬, 第i个龙鳞火炬的坐标为(x_i, y_i) (1≤i≤n).
// 目前你的位置在第一个龙鳞火炬处, 而你的目的地则是第n个龙鳞火炬处旁的熔岩湖。
// 你需要借助龙鳞火炬到达目的地。
// 你有e瓶幽蓝药剂, 每瓶幽蓝药剂可以让你施展一次暗影冲刺, 瞬间传送到距离你当前位置不超过r_1的任意一个龙鳞火炬处。
// 你需要在药剂用尽前到达目的地。
// 你还有1瓶龙血精华, 每瓶龙血精华可以让你接下来的p次暗影冲刺从r_1爆发到r_2。
// 但要注意，不到万不得已，不要使用龙血精华。
// 请你仔细规划你的路线, 计算出你至少需要使用多少瓶龙血精华(不使用为0, 使用为1)和多少瓶幽蓝药剂才能到达目的地。

// 输入描述:
// 输入的第一个数T表示测试用例的个数，后面跟着T个测试用例。
// 每个测试用例的格式为：
// 第一行包含5个整数n, e, p, r_1, r_2, 
// 分别代表龙鳞火炬的数量、幽蓝药剂的数量、使用龙血精华后暗影冲刺的爆发次数、暗影冲刺的普通距离和爆发距离。
// 接下来n行, 每行包含2个整数x_i, y_i, 分别代表第i个龙鳞火炬的坐标。每个坐标不相同。
// 输出描述:
// 若无法到达, 输出-1 -1。
// 若可以到达, 输出一行包含2个整数, 分别代表最少需要使用的龙血精华数量和幽蓝药剂数量。。

// 实例1:
// 输入:
// 1
// 5 10 3 5 15
// 0 0
// 3 4
// 6 0
// 9 4
// 12 0
// 输出:
// 0 4
// 说明: 
// 火炬坐标：(0, 0), (3, 4), (6, 0), (9, 4), (12, 0)。
// 普通冲刺距离 r1 = 5，强化冲刺距离 r2 = 15。
// 最优路径：
// 从火炬 1 到火炬 2：距离 5，普通冲刺即可（药剂消耗 1）。
// 从火炬 2 到火炬 3：距离 5，普通冲刺（药剂消耗 1）。
// 从火炬 3 到火炬 4：距离 5，普通冲刺（药剂消耗 1）。
// 从火炬 4 到火炬 5：距离 5，普通冲刺（药剂消耗 1）。
// 全程共消耗 4 药剂，无需使用龙血精华。

// 实例2:
// 输入:
// 1
// 5 4 2 5 10
// 1 0
// 26 0
// 16 0
// 6 0
// 31 0
// 输出:
// 1 4
// 说明: 
// 火炬坐标：(1, 0), (26, 0), (16, 0), (6, 0), (31, 0)。
// 普通冲刺距离 r1 = 5，强化冲刺距离 r2 = 10。
// 最优路径：
// 从火炬 1 到火炬 4：距离 5，普通冲刺即可（药剂消耗 1）。
// 从火炬 4 到火炬 3：距离 10，需要饮用龙血精华后冲刺（同时药剂消耗 1）。
// 从火炬 3 到火炬 2：距离 10，龙血药剂仍然生效，直接冲刺（药剂消耗 1）。
// 从火炬 2 到火炬 5：距离 5，龙血药剂已失效，普通冲刺即可（药剂消耗 1）。
// 全程共使用 1 龙血精华，消耗 4 药剂。

// 实例3:
// 输入:
// 1
// 6 10 10 10 13
// 0 0
// 20 0
// 10 0
// 20 10
// 10 5
// 20 23
// 输出:
// 1 3
// 说明: 
// 火炬坐标：(0, 0), (20, 0), (10, 0), (20, 10), (10, 5), (20, 23)。
// 普通冲刺距离 r1 = 10，强化冲刺距离 r2 = 13。
// 最优路径：
// 从火炬 1 到火炬 5：距离约 11.2，需要饮用龙血精华后冲刺（同时药剂消耗 1）。
// 从火炬 5 到火炬 4：距离约 11.2，龙血药剂仍然生效，直接冲刺（药剂消耗 1）。
// 从火炬 4 到火炬 6：距离 13，龙血药剂仍然生效，直接冲刺（药剂消耗 1）。
// 全程共使用 1 龙血精华，消耗 3 药剂。

#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

const int INF = 1e9;    
struct Torch {
    int x, y;
};

int n, e, p, r1, r2;
vector<Torch> torches;  
int dp[105][105][2];  // dp[i][j][k][l][m] 表示第 i 个火炬到第 j 个火炬，使用了 k 个龙血精华，使用了 l 个幽蓝药剂，是否到达目的地，是否使用龙血精华

int dist(int x1, int y1, int x2, int y2) {
    return abs(x1 - x2) + abs(y1 - y2);
}

int main() {
    cin >> n >> e >> p >> r1 >> r2;
    for (int i = 0; i < n; i++) {
        int x, y;
        cin >> x >> y;
        torches.push_back({x, y});
    }
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            for (int k = 0; k < 2; k++) {
                dp[i][j][k] = INF;
            }
        }    
    }
    dp[0][1][0] = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            for (int k = 0; k < 2; k++) {
                if (dp[i][j][k] == INF) continue;
                for (int l = 0; l < 2; l++) {
                    for (int m = 0; m < e; m++) {
                        int x1 = torches[i-1].x, y1 = torches[i-1].y;
                        int x2 = torches[j-1].x, y2 = torches[j-1].y;
                        int d = dist(x1, y1, x2, y2);
                        if (d > r1) continue;
                        if (k == 0) {
                            dp[j][m+1][0] = min(dp[j][m+1][0], dp[i][j][k] + 1);
                            if (p > 0) {
                                dp[j][m+1][1] = min(dp[j][m+1][1], dp[i][j][k] + 1);
                            }
                        } else {
                            dp[j][m+1][1] = min(dp[j][m+1][1], dp[i][j][k] + 1);
                        }
                    }
                }
            }    
        }
    }
    if (dp[n][e][0] == INF) {
        cout << -1 << " " << -1 << endl;
    } else {
        cout << dp[n][e][0] << " " << dp[n][e][1] << endl;
    }
    return 0;
}
